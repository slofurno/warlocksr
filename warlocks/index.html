<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
</head>
<body>

    <script src="Scripts/jquery-1.10.2.min.js"></script>
    <!--Reference the SignalR library. -->
    <script src="Scripts/jquery.signalR-2.1.0.js"></script>

    <script src="Scripts/knockout-min.js"></script>
    <!--Reference the autogenerated SignalR hub script. -->
    <script src="/signalr/hubs"></script>
    <script src="bitmap.js"></script>


    <div style="z-index:-1; position:absolute;">
        <canvas id="myCanvas" width="1000" height="1000" style="width:1000px; height:1000px;"></canvas>

            
</div>



        <script>

            var starttime;
            var iterations = 0;
            var fps = 0;

            var controller = { dleft: 0, dright: 0, dup: 0, ddown: 0, rightx: 0, righty: 0, righttrigger: 0, buttons: [0,0,0,0] };
            var tempelements = [];
            var playerarray = [];

            var c = document.getElementById("myCanvas");
            var ctx = c.getContext("2d");
            ctx.clearRect(0, 0, 1000, 1000);
           
            ctx.fillStyle = "blue";
            ctx.fillRect(0, 0, 1000, 1000);
            var level = new bitmap('testlevel.png');
            var colorwhite = new color(255, 0, 0, 255);

            controller.toString = function () {

                var str = "dleft " + this.dleft + "dright " + this.dright + "dup " + this.dup + "ddown " + this.ddown + "rightx " + this.rightx + "righty " + this.righty + "righttrigger " + this.righttrigger;

                return str;

            }

            function tick() {
                window.requestAnimationFrame(tick);
                GetInput(controller);

                SendCommand({ view: { X: controller.rightx, Y: controller.righty }, vel: { X: controller.dright - controller.dleft, Y: controller.ddown - controller.dup }, buttons: controller.buttons });

                level.redraw(ctx);
                
                $.each(playerarray, function (index, player) {

                    //console.log("WTF " + player.view.Y + "   " + player.view.X);

                    var temp = tempelements[player.id];


                        //temp.style.left = '' + player.position.X + 'px';
                        //temp.style.top = '' + player.position.Y + 'px';

                        var angle = Math.round(Math.atan2(player.view.Y, player.view.X) * (180 / Math.PI));
                        temp.style.transform = 'translate(' + (player.position.X - 15) + 'px, ' + (player.position.Y - 15) + 'px) translateZ(0) rotate(' + angle + 'deg)';
                    
                });

                


                //console.log(playerarray);

                //console.log("axis 0" + controller.axes[0] + " " + controller.axes[1] + " " + controller.axes[2] + " " + controller.axes[3] + " " + controller.axes[4] + " " + controller.axes[5] + " ");

                iterations++;
                var currenttime = new Date;

                fps = (iterations / (currenttime - starttime)) * 1000;

                //console.log("fps : " + fps);


            }


            function SendCommand(command) {

                hub.server.sendInput(command);

            };


            function GetInput(controller) {

                if (navigator.getGamepads) {

                    var tolerance = .3;

                    controller.dleft = 0;
                    controller.dright = 0;
                    controller.dup = 0;
                    controller.ddown = 0;
                    controller.rightx = 0;
                    controller.righty = 0;
                    controller.righttrigger = 0;
                    controller.buttons[0] = 0;
                    controller.buttons[1] = 0;
                    controller.buttons[2] = 0;
                    controller.buttons[3] = 0;


                    var gamepadarray = navigator.getGamepads();

                    

                    if (gamepadarray.length > 0) {

                        var gamepad = gamepadarray[0];

                        //console.log(gamepad.mapping);

                        var buttons = gamepad.buttons;
                        var axes = gamepad.axes;

                        if (gamepad.axes.length < 6) {


                            //chrome reads dpad as buttons
                            controller.ddown = buttons[13].value;
                            controller.dup = buttons[12].value;
                            controller.dleft = buttons[14].value;
                            controller.dright = buttons[15].value;


                            if (buttons[7].value >= tolerance) {
                                controller.righttrigger = 1;
                            }

                            //chrome reads x and y from different index then firefox
                            

                            if (Math.abs(axes[2]) > tolerance) {
                                controller.rightx = axes[2];
                            }
                            if (Math.abs(axes[3]) > tolerance) {
                                controller.righty = axes[3];
                            }



                        }
                        else {
                            //firefox reads dpad as axes

                            if (axes[5] == -1) {
                                controller.dleft = 1;
                            }
                            else if (axes[5] == 1) {
                                controller.dright = 1;

                            }
                            if (axes[6] == -1) {
                                controller.dup = 1;

                            }
                            else if (axes[6] == 1) {
                                controller.ddown = 1;
                            }

                            if (axes[4] <= -tolerance) {
                                controller.righttrigger = 1;
                            }

                            if (Math.abs(axes[3]) > tolerance) {
                                controller.rightx = axes[3];
                            }
                            if (Math.abs(axes[2]) > tolerance) {
                                controller.righty = axes[2];
                            }
                            

                        }

                        for (var i = 0; i < 4; i++) {

                            controller.buttons[i] = buttons[i].value;

                        }

                        /*
                        for (var i = 0; i < gamepadarray[0].buttons.length; i++) {
                            if (gamepadarray[0].buttons[i].value > 0) {
                                console.log(i + "   " + gamepadarray[0].buttons[i].value);
                            }

                        }
                        */

                    }
                    else {
                        console.log("no gamepad detected");
                    }

                }


            }

            var hub = $.connection.warlocksHub;

            $.connection.hub.start().done(function () {

                //hub.server.startPlayer();
                starttime = new Date;

                level.test(colorwhite);
                tick();
                console.log("STARTING");

            });

            

            hub.client.updateState = function (players) {

                //console.log(players);

                $.each(players, function (index, player) {

                    if (typeof playerarray[player.id] == 'undefined') {

                        //console.log("is this even defined? " + player.id);

                        playerarray[parseInt(player.id)] = new Player(player.id, player.position, player.view);

                        var newDiv = document.createElement("div");
                        newDiv.style.position = "absolute";
                        
                        newDiv.innerHTML="<IMG SRC = 'img/person.png'>"
                        //var newContent = document.createTextNode(":D");
                        //newDiv.appendChild(newContent); //add the text node to the newly created div


                        tempelements[player.id] = newDiv;
                        document.body.appendChild(newDiv);
                        
                        

                    }
                    else {

                        playerarray[player.id].update(player.position, player.view);
                    }

                    //console.log(player.position.X + "   " +  player.position.Y + "   "  + player.view.X + "    " + player.view.Y);
                    //playerarray[index] = player;

                });

            };


            hub.client.updatePixels = function (pixels) {

                $.each(pixels, function (index, pixel) {

                    level.setPixel(pixel.X, pixel.Y, colorwhite);
                    console.log("X : " + pixel.X + "  Y:  " + pixel.Y);

                });

            };

            function Vector2(x, y) {
                this.X = x;
                this.Y = y;
            }

            function Player(id, position, view) {

                this.id = parseInt(id);
                this.position = new Vector2(position.X, position.Y);
                this.view = new Vector2(view.X, view.Y);

                this.update = function (newposition, newview) {

                    this.position.X =newposition.X;
                    this.position.Y =newposition.Y;
                    this.view.X=newview.X;
                    this.view.Y=newview.Y;


                };
            }

            var testViewModel = {
                playerList: ko.observableArray(playerarray),
                

            };

            ko.applyBindings(testViewModel);


        </script>












</body>
</html>
